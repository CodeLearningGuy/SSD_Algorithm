import numpy as np
import time


# 改为矢量化计算能节省时间
start_time = time.time()
down_matrix = np.array([[0,0,0,0,2,2], [0,0,0,0,2,3], [1,0,0,0,2,3], [0,1,0,0,2,2], [0,1,0,0,3,2],
                        [1,0,1,0,1,2], [1,0,1,0,1,3], [2,0,1,0,1,3], [2,0,2,0,0,2], [2,0,2,0,0,3],
                        [3,0,2,0,0,3], [2,2,0,0,0,0], [2,2,0,0,0,1], [3,2,0,0,0,1], [2,3,0,0,0,0],
                        [2,3,0,0,1,0], [1,1,0,0,1,1], [1,1,0,0,1,2], [2,1,0,0,1,2], [1,2,0,0,1,1],
                        [1,2,0,0,2,1], [2,1,1,0,0,1], [3,1,1,0,0,1], [3,1,1,0,0,2], [0,1,0,1,2,1],
                        [0,1,0,1,3,1], [0,2,0,1,3,1], [1,2,0,1,1,0], [1,3,0,1,1,0], [1,3,0,1,2,0],
                        [0,2,0,2,2,0], [0,3,0,2,2,0], [0,3,0,2,3,0]])
up_matrix = np.array([[3,0,3,3,3,2],[0,0,3,3,2,3],[3,0,0,3,2,3],[0,3,3,3,2,3],[0,3,3,0,3,2],
                      [3,0,3,3,1,2],[1,0,3,3,1,3],[3,0,1,3,1,3],[3,0,3,3,0,2],[2,0,3,3,0,3],
                      [3,0,2,3,0,3],[3,2,3,3,3,0],[2,2,3,3,0,3],[3,2,0,3,0,3],[2,3,3,3,0,3],
                      [2,3,3,0,3,0],[3,1,3,3,3,1],[1,1,3,3,1,3],[3,1,0,3,1,3],[1,3,3,3,1,3],
                      [1,3,3,0,3,1],[2,1,3,3,0,3],[3,1,3,3,0,1],[3,1,1,3,0,3],[0,3,3,3,2,1],
                      [0,1,3,3,3,1],[0,3,3,1,3,1],[1,2,3,3,3,0],[1,3,3,3,1,0],[1,3,3,1,3,0],
                      [0,2,3,3,3,0],[0,3,3,3,2,0],[0,3,3,2,3,0]])
R = 0
prob = np.ones((6, 4), dtype=int) * np.array([0.25,0.3,0.25,0.2])
for i in range(down_matrix.shape[0]):
    temp_p = np.zeros(6)
    down = down_matrix[i, :]
    up = up_matrix[i, :]
    for j in range(temp_p.shape[0]):
        temp_p[j] = np.sum(prob[j, (down[j]):(up[j] + 1)])
    R += np.prod(temp_p)
cal_time = time.time() - start_time

print("d=2时的可靠度：", R)
print("计算时间：", cal_time)
